#  View的更新

大多数面向对象的GUI程序(UIKit APP,浏览器中的DOM文档对象模型App)
有两条与View相关的代码路径
1.处理view的初始构造
2.负责在事件发生时更新View

弊端:路径分开,且涉及手动更新,很容易出现错误  ❌ ,造成View和Model不同步,使app产生不确定行为,卡死或者崩溃

APPKit : Cocoa Binding技术 model与view保持同步的双向层
UIKit: 响应式编程


SwiftUI的设计: 只有view的body属性这一条代码路径
- 用于构造初始的View
- 所有后续的更新

无法绕过View的生命周期,无法直接修改view树.对body进行重新求值是唯一的办法.


如何更新?
方案一:丢弃掉当前所有内容,从头开始重新绘制屏幕
特点:低效,需要重新创建底层的View对象(可能很昂贵),view状态的丢失:滚动位置,当前选中的内容,很难被轻易的保存并应用到新的view上去.


SwiftUI需要知道哪些View对象需要更改,添加或删除.
即需要将先前view树的值(body求值的结果)与当前View树🌲的值(状态改变后重新对body求值的结果)

SwiftUI中的view树里的元素类型在每次更新时都是相同的,即每次都拥有相同的结构,重新渲染的任务将会更简单和高效

🌲树的diff算法(比较两棵树结构之间不同之处的算法)的算法复杂度是O(n^3)
React使用了具有O(n)复杂的启发式diff算法,在diff的精度和效率之间进行了权衡,可能会导致实际被重建的部分要比严格意义上真正需要重建的部分更大,开发者可能会需要提供一些提示,来表明树的那些部分在更新时是稳定的,从而应对这种影响


SwiftUI:
view树的结构在更新时始终相同,不需要执行完整的diff,可以简单的同时遍历旧树和新树
