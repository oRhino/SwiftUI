#  可视化

interfacebuilder（IB）和故事板帮助我们很多人加快了开发应用程序的速度，使得布局自适应用户界面和设置导航segue变得容易。

但是许多开发人员更喜欢用代码创建他们的产品视图，部分原因是在代码中编写UI时，复制或编辑UI更为高效，但主要是因为IB和情节提要都有内置的陷阱。编辑IBAction或IBOutlet的名称或将其从代码中删除，应用程序就会崩溃，因为IB看不到代码的更改。或者，您对代码中必须使用的段或表视图单元格的字符串类型标识符感到愤怒，但Xcode无法检查，因为它们是字符串。

SwiftUI允许您忽略Interface Builder（IB）和情节提要，而无需编写详细的分步说明来布置UI。你可以用它的代码并排预览一个SwiftUI视图，对一边的更改会更新另一边，因此它们总是同步的。没有任何标识符字符串会出错。这是代码，但比为UIKit编写的代码要少很多，所以更容易理解.


SwiftUI使您能够进行声明性的应用程序开发。你将更快地开发出优秀的应用程序。。。一旦你学会了“另辟蹊径”。声明性应用程序开发意味着你既要声明你希望UI中的视图看起来如何，也要声明它们所依赖的数据。SwiftUI框架负责在视图应该出现时创建视图，并在它们所依赖的数据发生变化时更新视图。

您可以声明视图的状态如何影响它的外观，以及SwiftUI应该如何响应视图的数据依赖项中的更改。是的，斯威夫图有一种明确的反应性感觉！因此，如果您已经在使用一种反应式编程框架，那么使用SwiftUI可能会更容易。

这些功能有助于加快应用程序开发速度：
视图：声明性UI与代码保持同步，没有字符串类型的标识符。使用视图进行布局和导航，并封装一段数据的表示逻辑。声明式UI的另一个好处是：API跨平台是一致的，因此您可以学习一次，然后在任何地方应用。控件描述它们的角色，而不是它们的外观，因此“同一个控件看起来适合平台”。你将在第5章“苹果生态系统”中了解更多其他平台。

数据：声明性数据依赖项在数据更改时更新视图。框架重新计算视图及其所有子视图，然后呈现已更改的内容。视图的状态取决于其数据，因此您可以声明视图如何使用数据：视图如何对数据更改作出反应，或者数据如何影响视图。您可以声明视图的可能状态，以及视图在每个状态下的显示方式。

导航：条件子视图可以代替导航：见第11章：“列表和导航”。

集成：很容易将SwiftUI集成到UIKit应用程序中，反之亦然：参见第4章：“集成SwiftUI”

为了创建UIKit应用程序，我在故事板上布置了几个标签、一个按钮和三个滑块，将它们连接到视图控制器中的插座和操作，然后在操作和一些助手方法中编写代码，以使UI与滑块值的更改保持同步。当用户移动滑块时，其操作将更新颜色值、标签和标签的背景色。我必须思考做事的正确顺序。很容易忘记一步。

为了创建SwiftUI应用程序，你列出了颜色、文本、按钮和滑块子视图的顺序-比设置自动布局约束要容易得多！-并在每个子视图中声明它如何依赖于应用程序数据的更改。SwiftUI管理数据依赖关系以保持视图与其状态的一致性，因此您不必担心按正确的顺序执行操作或忘记更新UI对象。画布预览意味着您不需要故事板。子视图保持自身更新，因此您也不需要视图控制器。实时预览意味着你很少需要启动模拟器。

省时，对吧？

第一个选项卡列出控件、布局、绘制和其他视图的基本视图。其中许多视图，尤其是控件视图，作为UIKit元素对您来说是熟悉的，但是有些是SwiftUI特有的。你将在接下来的章节中学习如何使用它们。

第二个选项卡列出了控件、效果、布局、文本等的修改器。修饰符是从现有视图创建新视图的方法。可以像管道一样链接修改器来自定义任何视图。

SwiftUI鼓励您创建可重用的小视图，然后使用修饰符对它们进行定制，以适应您使用它们的特定上下文。不用担心，SwiftUI会将修改后的视图折叠成一个高效的数据结构，这样您就可以获得所有这些便利，而不会对性能造成明显的影响。

您可以将其中许多修改器应用于任何类型的视图。有时订购很重要，您很快就会看到。

几个环境值会影响整个应用程序。其中许多与设备用户设置（如辅助功能、区域设置、日历和配色方案）相对应。您可以在预览中尝试环境值，以预测和解决用户设备上这些设置可能产生的问题。在本章后面，您将看到另一种（更简单）检查环境问题的方法。

您可以在中找到内置环境值的列表apple.co/2yJJk7T.

看看这些是怎么回事，打开天窗内容视图.swift. 向下滚动到ContentView_Previews并将此环境修改器添加到ContentView：

.environment（\.colorScheme，.dark）

接下来，在ContentView中，将此修饰符添加到顶层VStack：

.background（颜色（.systemBackground））

您要确保视图的背景色更改为黑色以适应暗模式。

刷新预览，现在它处于暗模式！”


“SwiftUI有两个指导原则来管理数据在应用程序中的流动方式：

dataaccess=dependency：读取视图中的一段数据会为该视图中的数据创建一个依赖关系。每个视图都是其数据依赖关系的函数—输入或状态。

单一真实源：视图读取的每个数据块都有一个真实源，该源要么为视图所有，要么位于视图外部。不管真理的源头在哪里，你应该始终只有一个真理的来源。这就是为什么您没有在ColorSlider中声明@State value。它会创造出一个重复的真相来源，你必须与rValue保持同步。相反，另一个视图的@State声明的值取决于另一个视图的@State。

在UIKit中，视图控制器使模型和视图保持同步。在SwiftUI中，声明性视图层次结构加上这个单一的真实源意味着您不再需要视图控制器。”


数据流工具

SwiftUI提供了几个工具来帮助您管理应用程序中的数据流。

属性包装器增强了变量的行为。SwiftUI特定的包装器-@State、@Binding、@ObservedObject和@EnvironmentObject-声明视图对变量表示的数据的依赖关系。

每个包装器指示不同的数据源：

@状态变量归视图所有。@State var分配持久存储，因此必须初始化其值。苹果建议您将这些标记为private，以强调@State变量是由该视图专门拥有和管理的。

注意：您可以在ContentView中初始化@State变量，以消除从SceneDelegate传递参数的需要。否则，如果将它们设为私有，则无法将ContentView初始化为根视图。

@Binding声明对另一个视图拥有的@State var的依赖关系，该视图使用$前缀将该状态变量的绑定传递给另一个视图。在接收视图中，@Binding var是对数据的引用，因此不需要初始值。此引用使视图能够编辑依赖于此数据的任何视图的状态。

@ObservedObject声明对符合observeobject协议的引用类型的依赖性：它实现objectWillChange属性来发布对其数据的更改。您很快就会将计时器实现为ObservableObject。

@EnvironmentObject声明了对某些共享数据的依赖关系，这些数据对应用程序中的所有视图都可见。这是一种方便的间接传递数据的方法，而不是将数据从父视图传递到子视图再传递给子视图，尤其是在子视图不需要它的情况下。

通常不在可重用视图中使用@State变量。请改用@Binding或@ObservedObject。只有当视图应该拥有数据时，才应该创建private@State var，比如Button的突出显示属性。考虑数据是由父视图还是由外部源拥有。

声明式应用程序开发意味着您既要声明用户界面中视图的外观，也要声明它们所依赖的数据。SwiftUI框架负责在视图应该出现时创建视图，并在它们所依赖的数据发生变化时更新视图。

该库包含一个基本视图列表和一个修饰符方法列表。

一些修饰符可以应用于所有视图类型，而其他修饰符只能应用于特定的视图类型，如文本。改变修改器的顺序可以改变视觉效果。

dataaccess=dependency：读取视图中的一段数据会为该视图中的数据创建一个依赖关系。

单一真相来源：每一条数据都有一个真相来源，内部或外部。不管真理的源头在哪里，你应该始终只有一个真理的来源。

属性包装扩展了变量的行为：@State、@Binding、@ObservedObject和@EnvironmentObject声明视图对变量所表示数据的依赖关系。

@绑定声明对另一个视图拥有的@State var的依赖关系。@ObservedObject声明对符合ObservableObject的引用类型的依赖关系。“@ObservedObject声明对符合observeObject的引用类型的依赖性。@EnvironmentObject声明对某些共享数据的依赖关系。

对于运行时调试，请控制单击或右键单击“实时预览”按钮，然后从菜单中选择“调试预览”。您可以获得所有正常的调试工具，以及运行时问题扫描和运行时断点。选项单击“视图调试器”图标以打开视图调试器。


